from dataclasses import dataclass, field
from typing import Any, Optional, Set
import uuid
from bec.helpers.converter import (
    energy_to_wavelength_nm,
    wavelength_to_energy_eV,
)
from bec.light.envelopes import Envelope
from bec.params.transitions import TransitionRole, TransitionType


@dataclass
class LightMode:
    """
    Representation of a single optical mode interacting with a quantum dot.

    A `LightMode` describes either an excitation (drive) or emission channel
    associated with a quantum dot transition. Each mode can be defined by
    either its wavelength (in nanometers) or its photon energy
    (in electronvolts), but not both simultaneously. The missing quantity is
    derived automatically.

    Parameters
    ----------
    wavelength_nm : float, optional
        Central wavelength of the mode in nanometers. Mutually exclusive with
        `energy_ev`.
    energy_ev : float, optional
        Photon energy of the mode in electronvolts. Mutually exclusive with
        `wavelength_nm`.
    source : TransitionType, optional
        Underlying quantum dot transition that gives rise to this mode.
    envelope : Envelope, optional
        Temporal or spectral envelope shaping the mode
        (e.g. Gaussian, square pulse).
    role : TransitionRole
        Role of the mode with respect to the transition
        (defaults to `TransitionRole.SINGLE`).
    tpe_eliminated : set of TransitionType
        Set of transitions eliminated under two-photon excitation (TPE).
        This is managed internally and not user-settable.
    tpe_alpha_X1 : float
        Amplitude weight for X1 exciton under TPE.
    tpe_alpha_X2 : float
        Amplitude weight for X2 exciton under TPE.

    Notes
    -----
    - Each `LightMode` instance is assigned a unique internal identifier
      (`__id`) to allow equality comparison and hashing beyond
      wavelength/energy alone.
    - Either `wavelength_nm` or `energy_ev` must be provided on initialization.
      Providing both or neither raises a `ValueError`.
    - Conversion helpers are used to ensure consistent energyâ€“wavelength
      relations.
    """

    wavelength_nm: Optional[float] = None
    energy_ev: Optional[float] = None
    source: Optional[TransitionType] = None
    envelope: Optional[Envelope] = None
    role: TransitionRole = field(init=False, default=TransitionRole.SINGLE)
    tpe_eliminated: Set[TransitionType] = field(
        init=False, default_factory=set)
    tpe_alpha_X1: float = 0.0
    tpe_alpha_X2: float = 0.0
    __id: uuid.UUID = field(init=False, default_factory=uuid.uuid4)

    def __post_init__(self):
        if (self.wavelength_nm is None and self.energy_ev is None) or (
            self.wavelength_nm is not None and self.energy_ev is not None
        ):
            raise ValueError(
                "Either wavelenght_nm or energy_ev must be given, but not both"
            )
        if self.wavelength_nm is None:
            assert isinstance(self.energy_ev, float)
            self.wavelength_nm = energy_to_wavelength_nm(self.energy_ev)
        if self.energy_ev is None:
            assert isinstance(self.wavelength_nm, float)
            self.energy_ev = wavelength_to_energy_eV(self.wavelength_nm)

    def __eq__(self, other: Any):
        if not isinstance(other, LightMode):
            return NotImplemented
        return self.__id == other.__id

    def __hash__(self):
        return hash((self.wavelength_nm, self.__id))
